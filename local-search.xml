<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python爬虫记录</title>
    <link href="/2023/09/25/Python%E7%88%AC%E8%99%AB%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/25/Python%E7%88%AC%E8%99%AB%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Python 爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高程期末复习</title>
    <link href="/2023/06/13/%E9%AB%98%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/13/%E9%AB%98%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#程序设计题">程序设计题</a><ul><li><a href="#递归化为尾递归">递归化为尾递归</a><ul><li><a href="#例子--斐波那契数列-">例子 ( 斐波那契数列 )</a></li><li><a href="#原理">原理</a></li><li><a href="#方法">方法</a></li></ul></li></ul></li><li><a href="#重点">重点</a></li><li><a href="#1-类与对象">1. 类与对象</a><ul><li><a href="#11-对象和类的概念">1.1 对象和类的概念</a></li><li><a href="#12-成员对象">1.2 成员对象</a></li><li><a href="#13-对象的访问控制">1.3 对象的访问控制</a></li><li><a href="#14-对象的初始化和消亡">1.4 对象的初始化和消亡</a></li><li><a href="#15-拷贝构造函数">1.5 拷贝构造函数</a></li><li><a href="#16-常量对象静态对象友元">1.6 常量对象,静态对象,友元</a></li></ul></li><li><a href="#2-继承-派生类">2. 继承-派生类</a><ul><li><a href="#21-单继承">2.1 单继承</a></li><li><a href="#22-信息的多态和动态绑定">2.2 信息的多态和动态绑定</a></li><li><a href="#23-抽象类">2.3 抽象类</a></li><li><a href="#24-多继承">2.4 多继承</a></li><li><a href="#25-聚合和组合">2.5 聚合和组合</a></li></ul></li><li><a href="#3-异常处理">3 异常处理</a></li><li><a href="#4-io">4. IO</a><ul><li><a href="#41-io介绍">4.1 IO介绍:</a></li><li><a href="#42-面向控制台的io">4.2 面向控制台的IO</a></li><li><a href="#43-类的操作符重载">4.3 类的操作符重载</a></li><li><a href="#44-面向文件的io">4.4 面向文件的IO</a></li></ul></li><li><a href="#5-操作符重载">5. 操作符重载</a><ul><li><a href="#51-要点">5.1 要点:</a></li><li><a href="#52-例子">5.2 例子:</a></li></ul></li><li><a href="#6-泛型stl">6. 泛型,STL</a><ul><li><a href="#61-泛型">6.1 泛型</a></li><li><a href="#62-stl">6.2 STL</a></li></ul></li><li><a href="#7-消息事件驱动的程序设计">7. 消息(事件)驱动的程序设计</a><ul><li><a href="#71-消息事件驱动的程序设计结构">7.1 消息(事件)驱动的程序设计结构</a></li><li><a href="#过程式windows程序设计">过程式Windows程序设计</a></li><li><a href="#面向对象windows程序设计">面向对象Windows程序设计</a></li></ul></li><li><a href="#8-函数式逻辑式编程">8. 函数式,逻辑式编程</a><ul><li><a href="#81-程序设计范式">8.1 程序设计范式</a></li><li><a href="#82-函数式程序设计">8.2 函数式程序设计</a></li><li><a href="#83-逻辑式程序设计">8.3 逻辑式程序设计</a></li></ul></li></ul><h1 id="程序设计题"><a href="#程序设计题" class="headerlink" title="程序设计题"></a>程序设计题</h1><h2 id="递归化为尾递归"><a href="#递归化为尾递归" class="headerlink" title="递归化为尾递归"></a>递归化为尾递归</h2><h3 id="例子-斐波那契数列"><a href="#例子-斐波那契数列" class="headerlink" title="例子 ( 斐波那契数列 )"></a>例子 ( 斐波那契数列 )</h3><p>递归方式:<br><figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>)+<span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>尾递归方式:<br><figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>, b, a+b);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>尾递归是指一个函数在调用自身之后不再执行任何其他操作，而是将返回值直接传递给函数调用的上级，从而避免了新的调用栈帧的创建。换句话说，尾递归是指递归调用发生在函数的最后一个语句中，从而使得函数调用不需要保存多个调用栈帧，而只需一个即可</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>递归函数的参数中增加一个参数，用于保存递归函数的中间结果。</li><li>返回值那里不要写计算方法，而是直接写函数自己。</li><li>在函数体中，每次递归调用时，都要更新参数的值。</li></ol><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><h1 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1. 类与对象"></a>1. 类与对象</h1><h2 id="1-1-对象和类的概念"><a href="#1-1-对象和类的概念" class="headerlink" title="1.1 对象和类的概念"></a>1.1 对象和类的概念</h2><p>对象构成了面向对象程序的基本计算单位，而对象的特征则由相应的类来描述<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011102392-863525651.png" alt="img"></p><h2 id="1-2-成员对象"><a href="#1-2-成员对象" class="headerlink" title="1.2 成员对象"></a>1.2 成员对象</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011110294-2059839477.png" alt="img"></p><h2 id="1-3-对象的访问控制"><a href="#1-3-对象的访问控制" class="headerlink" title="1.3 对象的访问控制"></a>1.3 对象的访问控制</h2><ul><li>public: 任何程序都可以访问</li><li>private: 只有类的成员函数和友元函数可以访问</li><li>protected: 只有类的成员函数、友元函数和派生类的成员函数可以访问<h2 id="1-4-对象的初始化和消亡"><a href="#1-4-对象的初始化和消亡" class="headerlink" title="1.4 对象的初始化和消亡"></a>1.4 对象的初始化和消亡</h2></li><li>初始化: 通过构造函数来完成<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011121116-1165736276.png" alt="img"><figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">A *p1=<span class="hljs-keyword">new</span> A;     <span class="hljs-comment">//调用默认构造函数</span><br>A *p2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);     <span class="hljs-comment">//调用A(int i)</span><br>A *p3=<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;xyz&quot;</span>);    <span class="hljs-comment">//调用A(char *)</span><br>A *p4=<span class="hljs-keyword">new</span> A[<span class="hljs-number">20</span>];   <span class="hljs-comment">//创建动态对象数组时</span><br>  !!只能调用各对象的默认构造函数<br><br>在程序中也可以通过类的构造函数来创建一些临时对象。例如：<br>A a;<br>......<br>a = <span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//创建一个临时对象并把它赋值给a</span><br><br></code></pre></td></tr></table></figure><blockquote><p>PS: 常量和引用只能通过构造函数来初始化</p><figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++">对于常量和引用数据成员，不能在说明它们时初始化，也不能采用赋值操作在构造函数中对它们初始化。例如： <br>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&gt;&#123;<span class="hljs-type">int</span> x;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;   <span class="hljs-comment">//Error</span><br>    <span class="hljs-type">int</span> &amp;z=x;     <span class="hljs-comment">//Error</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123; x = <span class="hljs-number">0</span>;    <span class="hljs-comment">//OK</span><br>     y = <span class="hljs-number">1</span>;    <span class="hljs-comment">//Error  </span><br>   z = &amp;x;  <span class="hljs-comment">//Error    </span><br>   z = x;  <span class="hljs-comment">//Error   </span><br>    &#125;<br>&gt;&#125;;<br><br><br>&gt;可以在构造函数的函数头和函数体之间加入一个成员初始化表来对常量和引用数据成员进行初始化。例如：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;  <span class="hljs-type">int</span> x;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> y;<br>  <span class="hljs-type">int</span>&amp; z;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(): <span class="hljs-built_in">z</span>(x),<span class="hljs-built_in">y</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//成员初始化表</span><br>  &#123; x = <span class="hljs-number">0</span>;<br>  &#125;<br>&gt;&#125;;<br>在成员初始化表中，成员的书写次序并不决定它们的初始化次序，它们的初始化次序由它们在类定义中的描述次序来决定。<br></code></pre></td></tr></table></figure></blockquote></li><li>消亡: 通过析构函数来完成</li><li>成员对象的初始化和消亡处理:<ul><li>创建:<br>在创建包含成员对象的对象时，除了会自动调用本身类的构造函数外，还会自动去调用成员对象类的构造函数。<ul><li>通常是调用成员对象类的默认构造函数。</li><li>如果要调用成员对象类的非默认构造函数，需要在包含成员对象的对象类的构造函数成员初始化表中显式指出！</li><li>先执行成员对象类的构造函数，再执行本对象类的构造函数。</li><li>若包含多个成员对象，这些成员对象的构造函数执行次序则按它们在本对象类中的说明次序进行。</li><li>从实现上说，<ul><li>是先调用本身类的构造函数，但在进入函数体之前，会去调用成员对象类的构造函数，然后再执行本身类构造函数的函数体！</li></ul></li></ul></li><li>消亡:<br>包含成员对象的对象消亡时，除了会自动调用本身类的析构函数外，还会自动去调用成员对象类的析构函数。<ul><li>先执行本身类的析构函数，再执行成员对象类的析构函数。</li><li>如果有多个成员对象，则成员对象析构函数的执行次序则按它们在本对象类中的说明次序的逆序进行。   </li></ul></li></ul></li></ul><h2 id="1-5-拷贝构造函数"><a href="#1-5-拷贝构造函数" class="headerlink" title="1.5 拷贝构造函数"></a>1.5 拷贝构造函数</h2><p>自定义的拷贝构造函数,<br> 注意:默认调用的是成员对象类的默认构造函数来对成员对象初始化！<br><figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123; x++; y++; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;    <span class="hljs-type">int</span> z;<br>  A a;<br>   <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">B</span>() &#123; z = <span class="hljs-number">0</span>; &#125;<br>  <span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; b) &#123; z = b.z; &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123; z++; a.<span class="hljs-built_in">inc</span>(); &#125;<br>&#125;;<br>...<br>B b1;  <span class="hljs-comment">//b1.z、b1.a.x和b1.a.y均为0</span><br>b1.<span class="hljs-built_in">inc</span>();  <span class="hljs-comment">//b1.z、b1.a.x和b1.a.y均变成了1</span><br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>; <span class="hljs-comment">//b2.z为1，b2.a.x和b2.a.y均为0</span><br>如何能让b2与b1一致呢？<br>在B类的拷贝构造函数的成员初始化表中显式指出！<br><br>如:<span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp;b) : <span class="hljs-built_in">a</span>(b.a) &#123; z = b.z; &#125;<br>此时<span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span> <span class="hljs-comment">//b2.z、b2.a.x和b2.a.y均为1</span></span><br><span class="hljs-function"><span class="hljs-keyword">class</span> A </span>&#123; ...... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123; <span class="hljs-type">int</span> z;<br>   A a;<br>  <span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">B</span>() &#123; ...... &#125;<br>   <span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp; b)  <span class="hljs-comment">//a();这里还要调用A的默认构造函数对a初始化！</span><br>   &#123; z = b.z;<br>      a = b.a;  <span class="hljs-comment">//这里是调用A的赋值操作给a赋值</span><br>   &#125;<br>   ......<br>&#125;;<br>B b1;<br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(b1)</span></span>;<br><br></code></pre></td></tr></table></figure></p><h2 id="1-6-常量对象-静态对象-友元"><a href="#1-6-常量对象-静态对象-友元" class="headerlink" title="1.6 常量对象,静态对象,友元"></a>1.6 常量对象,静态对象,友元</h2><ol><li>常成员函数:<br>为了防止在一个获取对象状态的成员函数中无意中修改对象的数据成员，可以把它说明成常成员函数。例如，<figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>; <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//常成员函数</span><br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//常成员函数</span><br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//常成员函数</span><br>  ......<br>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> year; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> day; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> month; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span> </span>&#123; year=y; month=m; day=d; &#125;<br>编译器一旦发现在常成员函数中修改数据成员的值，将会报错！<br>``````<br><br> 注意：常成员函数只约束对数据成员值的修改！ <br>```c++ &#123;.line-numbers&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;  <span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> *p;<br><span class="hljs-keyword">public</span>:<br>......<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123; x = <span class="hljs-number">10</span>; <span class="hljs-comment">//Error</span><br>   p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">20</span>]; <span class="hljs-comment">//Error </span><br>   <span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;ABCD&quot;</span>); <span class="hljs-comment">//因为没有改变p的值，</span><br>                                  <span class="hljs-comment">//编译程序认为OK！</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>常成员函数还有一个作用：标记常量对象能调用的函数，即，常量对象只能调用对象类中的常成员函数。例如：<figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123; <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set</span> <span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>   ......<br>&#125;； <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> Date &amp;d)</span> <span class="hljs-comment">//d是个常量对象！</span></span><br><span class="hljs-function"></span>&#123; ... d.<span class="hljs-built_in">get_day</span>() ... <span class="hljs-comment">//OK</span><br>   ... d.<span class="hljs-built_in">get_month</span>() ... <span class="hljs-comment">//OK</span><br>   ... d.<span class="hljs-built_in">get_year</span>() ... <span class="hljs-comment">//OK</span><br>   d.<span class="hljs-built_in">set</span> (<span class="hljs-number">2011</span>,<span class="hljs-number">3</span>,<span class="hljs-number">23</span>); <span class="hljs-comment">//Error</span><br>&#125;     <br></code></pre></td></tr></table></figure></li><li>静态数据成员<br>采用静态数据成员可以更好地实现同一个类的不同对象之间的数据共享。例如<figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123; <span class="hljs-type">int</span> y;<br>   ......<br>   <span class="hljs-type">static</span> <span class="hljs-type">int</span> x; <span class="hljs-comment">//静态数据成员声明</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>   </span>&#123; y = x; x++; ......   &#125;<br>&#125;;<br><span class="hljs-type">int</span> A::x=<span class="hljs-number">0</span>; <span class="hljs-comment">//静态数据成员定义及初始化</span><br>......<br>A a,b;<br>a.<span class="hljs-built_in">f</span>();<br>b.<span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//上述操作对同一个x进行</span><br>x++; <span class="hljs-comment">//Error，不通过A类对象不能访问x！</span><br></code></pre></td></tr></table></figure>注意：静态数据成员的初始化必须在类外进行！ </li><li>静态成员函数<br>成员函数也可以声明成静态的（静态成员函数）。<figure class="highlight c++"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<span class="hljs-type">int</span> x,y;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> shared;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get_shared</span><span class="hljs-params">()</span> <span class="hljs-comment">//静态成员函数</span></span><br><span class="hljs-function">     </span>&#123; <span class="hljs-keyword">return</span> shared; <br>     &#125;<br>......<br>&#125;;<br><span class="hljs-type">int</span> A::shared=<span class="hljs-number">0</span>;<br>静态成员函数只能访问类的静态成员。<br>静态成员函数没有隐藏的<span class="hljs-keyword">this</span>参数！<br>``````<br>静态成员除了通过对象来访问外，也可以直接通过类来访问。例如：<br>```c++ &#123;.line-numbers&#125;<br>A a;<br>...... <br>cout &lt;&lt; a.<span class="hljs-built_in">get_shared</span>();<br>或者<br>cout &lt;&lt; A::<span class="hljs-built_in">get_shared</span>(); <br></code></pre></td></tr></table></figure></li><li>友元<br>1.原因:根据数据封装的要求，类中定义的数据成员不能在外界直接访问，必须要通过类中定义的public成员函数来访问。在有些情况下，这种对数据的访问方式效率不高！<ol><li>性质:</li></ol><ul><li>友元不是一个类的成员。</li><li>友元关系具有不对称性。例如：假设B是A的友元，如果没有显式指出A是B的友元，则A不是B的友元。</li><li>友元也不具有传递性。例如：假设C是B的友元、B是A的友元，如果没有显式指出C是A的友元，则C不是A的友元。 <blockquote><p>例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">  &gt;把multiply说明成Matrix和Vector的友元<br>  &gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>; <span class="hljs-comment">//Vector的声明（由于在定义它前需要用到它）</span><br>  &gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span><br>  &gt;&#123;......<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix &amp;m, <span class="hljs-type">const</span> Vector &amp;v, </span></span><br><span class="hljs-params"><span class="hljs-function">Vector &amp;r)</span></span>; <span class="hljs-comment">//这里提前用到Vector。</span><br>  &gt;&#125;;<br>  &gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>  &gt;&#123;......<br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix &amp;m, <span class="hljs-type">const</span> Vector &amp;v, </span></span><br><span class="hljs-params"><span class="hljs-function">Vector &amp;r)</span></span>;<br>  &gt;&#125;;<br>  &gt;在multiply中直接访问Matrix和Vector的私有数据成员<br>  &gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix &amp;m, <span class="hljs-type">const</span> Vector &amp;v,Vector &amp;r)</span></span><br><span class="hljs-function">  &gt;</span>&#123;<br>  <span class="hljs-keyword">if</span> (m.col != v.num || m.row != r.num)<br>  &#123;cerr &lt;&lt; <span class="hljs-string">&quot;矩阵和向量的尺寸不匹配！\n&quot;</span>;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> *p_m=m.p_data,*p_r=r.p_data,*p_v;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m.row; i++)<br> &#123;*p_r = <span class="hljs-number">0</span>;<br>p_v = v.p_data;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;m.col; j++)<br>   &#123;<br>          *p_r += (*p_m)*(*p_v);<br>   p_m++;<br>   p_v++;<br>   &#125;<br>p_r++;<br>  &#125;<br>  &gt;&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul></li></ol><h1 id="2-继承-派生类"><a href="#2-继承-派生类" class="headerlink" title="2. 继承-派生类"></a>2. 继承-派生类</h1><p>定义:在定义一个新的类时，先把已有的一个或多个类的功能全部包含进来，然后再在新的类中给出新功能的定义或对已有类的某些功能进行重新定义，这个机制称为继承（Inheritance）</p><h2 id="2-1-单继承"><a href="#2-1-单继承" class="headerlink" title="2.1 单继承"></a>2.1 单继承</h2><ol><li>特点:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011145745-366023499.png" alt="img"></li><li>注意:</li></ol><ul><li>友元：<ul><li>如果在派生类中没有显式说明，则基类的友元不是派生类的友元；</li><li>如果基类是另一个类的友元，而该类没有显式说明，则派生类也不是该类的友元。(不传递)</li></ul></li><li>同名函数隐藏(同参,不同参都需类名限制来访问)<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011156850-235750352.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011203753-652948878.png" alt="img"></li></ul><ol><li>继承与封装的矛盾:</li></ol><ul><li>在派生类中定义新的成员函数或对基类已有成员函数重定义时，往往需要直接访问基类的一些private成员（特别是private数据成员），否则新的功能无法实现！</li><li>而类的private成员是不允许外界使用的（数据封装）！</li><li>这样就带来了继承与封装的矛盾。</li><li>protected访问控制缓解了封装与继承的矛盾</li></ul><ol><li><p>继承方式的不同:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011218339-390396497.png" alt="img"></p><blockquote><p>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011227282-1159741786.png" alt="img"></p></blockquote><ol><li>子类型:<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011250115-3708946.png" alt="img"></li></ol></li><li>执行顺序<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011258353-1898770183.png" alt="img"></li><li>拷贝构造函数<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011307583-2043219744.png" alt="img"><ol><li>派生类对象的赋值操作<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011315596-1702986421.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011328672-1245276426.png" alt="img"><h2 id="2-2-信息的多态和动态绑定"><a href="#2-2-信息的多态和动态绑定" class="headerlink" title="2.2 信息的多态和动态绑定"></a>2.2 信息的多态和动态绑定</h2></li></ol></li><li>消息的多态:<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011340147-1483591028.png" alt="img"><ol><li>消息的绑定 </li></ol></li></ol><ul><li>一般情况下，将在编译时刻根据对象的类型来决定采用哪一个消息处理函数（静态绑定）</li><li>基类的指针或引用可以指向或引用基类对象，也可以指向或引用派生类对象</li><li>当通过基类的指针或引用向它指向或引用的对象发送消息时，调用哪一个消息处理函数：基类或派生类？<ul><li>c++默认静态绑定<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011346281-931474752.png" alt="img"></li><li>可用虚函数指出动态绑定</li></ul></li><li>虚函数有两个作用：<ul><li>指定消息采用动态绑定。</li><li>指出基类中可以被派生类重定义的成员函数<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011354012-1095061720.png" alt="img"><blockquote><p>注意:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011403137-1280713619.png" alt="img"></p></blockquote></li></ul></li></ul><blockquote><p>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011410584-1140429925.png" alt="img"></p><p>动态绑定的实现:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011431669-836745825.png" alt="img"></p><h2 id="2-3-抽象类"><a href="#2-3-抽象类" class="headerlink" title="2.3 抽象类"></a>2.3 抽象类</h2><ol><li>要点:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011442524-481076750.png" alt="img"></li><li>抽象类的其他功能:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011451266-533463418.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011455128-467220173.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011459284-454341717.png" alt="img"><h2 id="2-4-多继承"><a href="#2-4-多继承" class="headerlink" title="2.4 多继承"></a>2.4 多继承</h2></li><li>要点:<ul><li>继承方式及访问控制的规定同单继承。</li><li>派生类拥有所有基类的所有成员。</li><li>基类的声明次序决定：<ul><li>对基类数据成员的存储安排。</li><li>对基类构造函数/析构函数的调用次序</li></ul></li></ul></li></ol></blockquote><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011509345-1130619742.png" alt="img"></p><ol><li>多继承的问题:名冲突,重复继承<ol><li>名冲突问题:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011526434-851243650.png" alt="img">解决方法:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011536108-1013340419.png" alt="img"></li><li>重复继承问题:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011544351-382768067.png" alt="img">解决方法:虚基类<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011552351-1222715450.png" alt="img"></li><li>虚基类:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011559978-1804753502.png" alt="img"><br>例子:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;    <span class="hljs-type">int</span> x;<br>   <span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;  <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>) &#123; y = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;  <span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>) &#123; z = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C <span class="hljs-comment">//包含虚基类A</span><br>&#123;  <span class="hljs-type">int</span> m;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k): <span class="hljs-built_in">B</span>(i), <span class="hljs-built_in">C</span>(j), <span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>) &#123; m = k; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>: <span class="hljs-keyword">public</span> D <span class="hljs-comment">//包含虚基类A</span><br>&#123;  <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">E</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l): <span class="hljs-built_in">D</span>(i,j,k), <span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>) &#123; n = l; &#125;<br>&#125;;<br>......<br><span class="hljs-function">D <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;  <span class="hljs-comment">//这里，A的构造函数由D调用，d.x初始化为3。</span><br>调用的构造函数及它们的执行次序是：<br><span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>)、<span class="hljs-built_in">B</span>(<span class="hljs-number">1</span>)、<span class="hljs-built_in">C</span>(<span class="hljs-number">2</span>)、<span class="hljs-built_in">D</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-function">E <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;  <span class="hljs-comment">//这里， A的构造函数由E调用，e.x初始化为4。</span><br>调用的构造函数及它们的执行次序是：<br><span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>)、<span class="hljs-built_in">B</span>(<span class="hljs-number">1</span>)、<span class="hljs-built_in">C</span>(<span class="hljs-number">2</span>)、<span class="hljs-built_in">D</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)、<span class="hljs-built_in">E</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <br><br></code></pre></td></tr></table></figure></li><li>虚基类实现:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011615433-399178458.png" alt="img"><h2 id="2-5-聚合和组合"><a href="#2-5-聚合和组合" class="headerlink" title="2.5 聚合和组合"></a>2.5 聚合和组合</h2></li></ol></li><li>聚合:<ul><li>在聚合关系中，被包含的对象与包含它的对象独立创建和消亡，被包含的对象可以脱离包含它的对象独立存在。例如，一个公司与它的员工之间是聚合关系。</li><li>聚合类的成员对象一般是采用对象指针表示，用于指向被包含的成员对象，被包含的成员对象是在外部创建，然后加入进来的。<br>例子:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; ...... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-comment">//B与A是聚合关系</span><br>&#123; A *pm; <span class="hljs-comment">//指向成员对象</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">B</span>(A *p) &#123; pm = p; &#125; <span class="hljs-comment">//成员对象在聚合类对象外部创建，然后传入</span><br>   ~<span class="hljs-built_in">B</span>() &#123; pm = <span class="hljs-literal">NULL</span>; &#125; <span class="hljs-comment">//传进来的成员对象不再是聚合类对象的成员</span><br>   ......<br>&#125;;<br>......<br>A *pa=<span class="hljs-keyword">new</span> A; <span class="hljs-comment">//创建一个A类对象</span><br>B *pb=<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(pa); <span class="hljs-comment">//创建一个聚合类对象，其成员对象是pa指向的对象</span><br>......<br><span class="hljs-keyword">delete</span> pb; <span class="hljs-comment">//聚合类对象消亡了，其成员对象并没有消亡</span><br>...... <span class="hljs-comment">// pa指向的对象还可以用在其它地方</span><br><span class="hljs-keyword">delete</span> pa; <span class="hljs-comment">//聚合类对象原来的成员对象消亡</span><br></code></pre></td></tr></table></figure></li></ul></li><li>组合:<ul><li>在组合关系中，被包含的对象随包含它的对象创建和消亡，被包含的对象不能脱离包含它的对象独立存在。例如，一个人与他的头、手和脚之间则是组合关系。</li><li>组合类的成员对象一般直接是对象，有时也可以采用对象指针表示，但不管是什么表示形式，成员对象一定是在组合类对象内部创建并随着组合类对象消亡。</li><li>实际上，private继承已经退化成组合了！</li></ul></li><li>继承与聚合/组合的关系:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011629181-1873753008.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011640470-2012897460.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011729032-1168316108.png" alt="img"></li></ol><h1 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3 异常处理"></a>3 异常处理</h1><ol><li>各种异常<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011745411-1721506737.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011751328-994150639.png" alt="img"></li><li>异常的处理:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011801311-396904461.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011809764-1487358165.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011816207-609300285.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011821153-1348516893.png" alt="img"><ol><li>异常的结构化处理: <img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011840510-648898575.png" alt="img"></li></ol></li></ol><ul><li>例子:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-function">ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename)</span></span>;<br>   <span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">fail</span>()) <br>     <span class="hljs-keyword">throw</span> filename; <span class="hljs-comment">//产生异常对象，报告错误情况</span><br>   <span class="hljs-type">int</span> x;<br>   cin &gt;&gt; x;<br>   ......<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>    ......<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-built_in">f</span>(str); &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">char</span> *fn) <span class="hljs-comment">//捕获异常</span><br>    &#123; ...... <span class="hljs-comment">//处理异常</span><br>    &#125;<br>    ...... <span class="hljs-comment">//正常情况</span><br>&#125;<br><br></code></pre></td></tr></table></figure><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011911385-1505396308.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011918015-708104665.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011922460-1066191199.png" alt="img"></li><li>例子:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> filename[<span class="hljs-number">100</span>];<br>cout &lt;&lt; “请输入文件名：” &lt;&lt; endl;<br>cin &gt;&gt; filename;<br><span class="hljs-keyword">try</span><br>&#123;<span class="hljs-built_in">f</span>(filename);<span class="hljs-comment">//如果在函数f中抛掷了char *类型的异常，</span><br>                 <span class="hljs-comment">//则程序转到try后面的catch(char *str)处理。</span><br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">char</span> *str)<br>&#123;cout &lt;&lt; str &lt;&lt; “不存在!”&lt;&lt; endl;<br>cout &lt;&lt; “请重新输入文件名：” &lt;&lt; endl;<br>cin &gt;&gt; filename;<br><span class="hljs-built_in">f</span>(filename); <span class="hljs-comment">//如果在函数f中又抛掷了异常呢？</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011936450-564117980.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011942563-727221644.png" alt="img"><ul><li>嵌套的异常处理:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011954517-329123942.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012000939-708038344.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012008895-590348463.png" alt="img"></li></ul></li></ul><ol><li>断言<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012015869-1760030774.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012020662-1862636498.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012024120-1505194566.png" alt="img"><h1 id="4-IO"><a href="#4-IO" class="headerlink" title="4. IO"></a>4. IO</h1><h2 id="4-1-IO介绍"><a href="#4-1-IO介绍" class="headerlink" title="4.1 IO介绍:"></a>4.1 IO介绍:</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012034803-1791224512.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012044489-1504951497.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012049154-1266388303.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012055555-839011843.png" alt="img"><h2 id="4-2-面向控制台的IO"><a href="#4-2-面向控制台的IO" class="headerlink" title="4.2 面向控制台的IO"></a>4.2 面向控制台的IO</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012102716-520128077.png" alt="img"><blockquote><p>注意:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012109786-2095941757.png" alt="img"></p></blockquote></li></ol><p>输出结果的控制:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012121050-916015743.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012125833-651742731.png" alt="img"><br>输入:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//遇到delim指定的字符为止，并自动加上一个&#x27;\0&#x27;字符。</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">istream::getline</span><span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">int</span> count, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">char</span> delim=<span class="hljs-string">&#x27;\n&#x27;</span>)</span></span>; <br></code></pre></td></tr></table></figure></p><h2 id="4-3-类的操作符重载"><a href="#4-3-类的操作符重载" class="headerlink" title="4.3 类的操作符重载"></a>4.3 类的操作符重载</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012135852-1351164696.png" alt="img"></p><h2 id="4-4-面向文件的IO"><a href="#4-4-面向文件的IO" class="headerlink" title="4.4 面向文件的IO"></a>4.4 面向文件的IO</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012158394-378372132.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012203849-1518477153.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012207627-138429641.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012211477-234921486.png" alt="img"></p><ul><li>打开文件:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012414008-329947703.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012420599-75832061.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012430028-811087484.png" alt="img"></li><li>关闭文件:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012441139-587318657.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012445499-1584980393.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012455633-619658799.png" alt="img"></li><li>输入输出文件指针:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012505762-1982216906.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012514233-941631281.png" alt="img"><h1 id="5-操作符重载"><a href="#5-操作符重载" class="headerlink" title="5. 操作符重载"></a>5. 操作符重载</h1><h2 id="5-1-要点"><a href="#5-1-要点" class="headerlink" title="5.1 要点:"></a>5.1 要点:</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012528598-822654156.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012532152-768466912.png" alt="img"><h2 id="5-2-例子"><a href="#5-2-例子" class="headerlink" title="5.2 例子:"></a>5.2 例子:</h2></li></ul><ol><li>双目操作符重载<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012545395-915078793.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012552542-1654274650.png" alt="img"></li><li>单目操作符重载<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012601097-1767542520.png" alt="img"><ol><li>++,—操作符的重载<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012614432-58589409.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012620339-522183710.png" alt="img"></li></ol></li><li>=号重载:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618161844521-1918287723.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618161815097-381077599.png" alt="img"></li><li>[]号重载: <img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618161917383-1382395323.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618162215253-367651366.png" alt="img"></li><li>new,delete重载:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618162323690-1928705020.png" alt="img"></li></ol><ul><li>new 的重载:<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618162341633-1376955993.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618162402721-1155459707.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618162435066-80876006.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618162446461-335404077.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163029155-939968798.png" alt="img"></li><li>delete的重载:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163107365-1391675142.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163120021-2024753237.png" alt="img"></li><li>空间分配:<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163423238-1589789107.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163528152-999755237.png" alt="img"></li><li>其他:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163709889-1765175842.png" alt="img"></li></ul><ol><li>()号重载:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163735681-1405825975.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163801969-1094263742.png" alt="img"></li><li>-&gt;重载:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163843050-1670221349.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163854241-1611934938.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618163938806-279922048.png" alt="img"></li><li>类型转换符重载:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618164315891-1595183115.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618164327162-1643896463.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618164356730-1985619892.png" alt="img"><h1 id="6-泛型-STL"><a href="#6-泛型-STL" class="headerlink" title="6. 泛型,STL"></a>6. 泛型,STL</h1><h2 id="6-1-泛型"><a href="#6-1-泛型" class="headerlink" title="6.1 泛型"></a>6.1 泛型</h2></li><li>概念:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012631289-1323437856.png" alt="img"></li><li>C++提供了两种实现类属函数的机制：<ul><li>采用通用指针类型的参数（C语言的做法）</li><li>函数模板</li></ul></li><li>函数模板:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012718232-1025490152.png" alt="img"></li><li><p>函数模板实例化:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012734128-31477250.png" alt="img"><br>如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">sort</span> (a,<span class="hljs-number">100</span>);  <br>实例化：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> elements[], <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count)</span> </span>&#123; ...... &#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012828259-546526298.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012838697-699325165.png" alt="img"></p></blockquote></li><li><p>带非类型参数的函数模板:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012849039-1774960659.png" alt="img"></p></li><li>类模板:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012856336-505941879.png" alt="img"><br>例子:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;T buffer[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> top;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Stack</span>() &#123; top = <span class="hljs-number">-1</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(T &amp;x)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-type">void</span> Stack &lt;T&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T &amp;x) &#123; ...... &#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-type">void</span> Stack &lt;T&gt;::<span class="hljs-built_in">pop</span>(T &amp;x) &#123; ...... &#125;<br></code></pre></td></tr></table></figure><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615012936376-1983306400.png" alt="img"><blockquote><p>注意:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013131399-696991869.png" alt="img"></p></blockquote></li><li>模板的复用:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013148402-505828838.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013155156-1428935609.png" alt="img"></li><li>类模板的友元:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013209214-1349944931.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013213647-1625398407.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013218133-1957629759.png" alt="img"><h2 id="6-2-STL"><a href="#6-2-STL" class="headerlink" title="6.2 STL"></a>6.2 STL</h2></li><li>内容:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013335330-63639575.png" alt="img"></li><li>迭代器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013347178-260951450.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013355628-735127762.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013410142-880535682.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013417218-473257172.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013424407-627827504.png" alt="img"></li><li>算法:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013446572-786426508.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013451140-1685255029.png" alt="img"></li></ol><ul><li>算法自定义操作:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013500951-956579697.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013504948-1750061101.png" alt="img"></li><li>$\lambda$表达式:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013519269-1339837230.png" alt="img"><h1 id="7-消息-事件-驱动的程序设计"><a href="#7-消息-事件-驱动的程序设计" class="headerlink" title="7. 消息(事件)驱动的程序设计"></a>7. 消息(事件)驱动的程序设计</h1><h2 id="7-1-消息-事件-驱动的程序设计结构"><a href="#7-1-消息-事件-驱动的程序设计结构" class="headerlink" title="7.1 消息(事件)驱动的程序设计结构"></a>7.1 消息(事件)驱动的程序设计结构</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013608396-264082290.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013611731-2136608716.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013617209-1403308567.png" alt="img"><h2 id="过程式Windows程序设计"><a href="#过程式Windows程序设计" class="headerlink" title="过程式Windows程序设计"></a>过程式Windows程序设计</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615010915411-2108189588.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615010903120-2107176371.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615010852940-1226289600.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615010838766-289561455.png" alt="img"><h2 id="面向对象Windows程序设计"><a href="#面向对象Windows程序设计" class="headerlink" title="面向对象Windows程序设计"></a>面向对象Windows程序设计</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011045469-1873281944.png" alt="img"><br><strong>Windows程序中的对象</strong><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011029432-1267877424.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011034390-383858329.png" alt="img"><h1 id="8-函数式-逻辑式编程"><a href="#8-函数式-逻辑式编程" class="headerlink" title="8. 函数式,逻辑式编程"></a>8. 函数式,逻辑式编程</h1><h2 id="8-1-程序设计范式"><a href="#8-1-程序设计范式" class="headerlink" title="8.1 程序设计范式"></a>8.1 程序设计范式</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011014077-778743591.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615011019173-234133628.png" alt="img"><h2 id="8-2-函数式程序设计"><a href="#8-2-函数式程序设计" class="headerlink" title="8.2 函数式程序设计"></a>8.2 函数式程序设计</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615010959781-2042606221.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615010950162-752500285.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615010937355-1368779891.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615010925209-1470234871.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615015442742-1672010280.png" alt="img"><br>基本操作:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615015819173-287636137.png" alt="img"><ul><li>尾递归:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615020328032-1779252228.png" alt="img"></li><li>过滤:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615020703008-1108588513.png" alt="img"></li><li>映射:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615021043010-1120101763.png" alt="img"></li><li>规约:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615021222063-731140535.png" alt="img"></li><li>部分函数应用:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615105313474-1577205273.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615105802342-901598293.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615110252482-1099180066.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615110326465-1579354448.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615110359249-1841671210.png" alt="img"></li><li>柯里化操作:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615110446055-1428738855.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615110511170-2018549987.png" alt="img"></li><li>区别:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615111108668-1310654121.png" alt="img"><h2 id="8-3-逻辑式程序设计"><a href="#8-3-逻辑式程序设计" class="headerlink" title="8.3 逻辑式程序设计"></a>8.3 逻辑式程序设计</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615111131092-1810454373.png" alt="img"></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数电期末复习</title>
    <link href="/2023/06/13/%E6%95%B0%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/13/%E6%95%B0%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#冯诺依曼结构">冯诺依曼结构</a></li><li><a href="#数据的编码">数据的编码</a><ul><li><a href="#数制的转换">数制的转换</a></li><li><a href="#数值数据的表示">数值数据的表示</a><ul><li><a href="#原码补码等转换">原码,补码等转换</a></li><li><a href="#ieee-754标准">IEEE 754标准:</a></li><li><a href="#数据基本宽度">数据基本宽度:</a></li></ul></li></ul></li><li><a href="#数字逻辑电路">数字逻辑电路</a><ul><li><a href="#概要">概要</a></li><li><a href="#数字逻辑基础">数字逻辑基础</a><ul><li><a href="#数字抽象">数字抽象:</a></li><li><a href="#cmos晶体管">CMOS晶体管:</a></li><li><a href="#cmos逻辑门的实现">CMOS逻辑门的实现:</a></li><li><a href="#卡诺图化简">卡诺图化简</a></li></ul></li><li><a href="#组合逻辑电路">组合逻辑电路</a><ul><li><a href="#概要-1">概要:</a></li><li><a href="#原则">原则:</a></li><li><a href="#组合逻辑电路设计">组合逻辑电路设计:</a></li><li><a href="#典型部件">典型部件:</a></li><li><a href="#延迟">延迟:</a></li><li><a href="#冒险">冒险:</a></li></ul></li><li><a href="#时序逻辑电路">时序逻辑电路</a><ul><li><a href="#概述">概述</a></li><li><a href="#锁存器触发器">锁存器,触发器</a></li><li><a href="#关于写入的时序关系">关于写入的时序关系:</a></li><li><a href="#同步时序逻辑电路设计">同步时序逻辑电路设计</a></li><li><a href="#典型部件设计">典型部件设计</a></li></ul></li><li><a href="#小结">小结</a></li></ul></li><li><a href="#存储器阵列了解">存储器阵列(了解)</a><ul><li><a href="#romram">ROM,RAM</a></li></ul></li><li><a href="#运算部件设计">运算部件设计</a><ul><li><a href="#基本的运算部件">基本的运算部件</a></li><li><a href="#定点数运算加减法乘法">定点数运算(加减法,乘法)</a></li><li><a href="#小结-1">小结</a></li></ul></li><li><a href="#指令系统">指令系统</a><ul><li><a href="#概述-1">概述</a></li><li><a href="#指令设计">指令设计</a></li><li><a href="#risc-v指令">RISC-V指令</a></li></ul></li><li><a href="#cpu">CPU</a><ul><li><a href="#概述-2">概述</a></li><li><a href="#cpu设计">CPU设计</a></li><li><a href="#流水线设计">流水线设计</a></li><li><a href="#流水线冒险">流水线冒险</a><ul><li><a href="#概要-2">概要</a></li><li><a href="#结构冒险">结构冒险</a></li><li><a href="#数据冒险">数据冒险</a></li><li><a href="#控制冒险">控制冒险</a></li></ul></li><li><a href="#比较">比较</a></li></ul></li></ul><h1 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h1><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013829457-1286032467.png" alt="img"></p><h1 id="数据的编码"><a href="#数据的编码" class="headerlink" title="数据的编码"></a>数据的编码</h1><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013839820-721165284.png" alt="img"></p><h2 id="数制的转换"><a href="#数制的转换" class="headerlink" title="数制的转换"></a>数制的转换</h2><p>二进制转8,16进制:按3或4位二进制编码转换<br>十进制转二进制:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615013943552-447272632.png" alt="img"></p><h2 id="数值数据的表示"><a href="#数值数据的表示" class="headerlink" title="数值数据的表示"></a>数值数据的表示</h2><ol><li>数值数据表示的三要素<ul><li>进位计数制</li><li>定、浮点表示</li><li>如何用二进制编码</li></ul></li></ol><p>即：要确定一个数值数据的值必须先确定这三个要素。  </p><ul><li>定/浮点表示（解决小数点问题）<ul><li>定点整数、定点小数</li><li>浮点数（可用一个定点小数和一个定点整数来表示）</li></ul></li><li>定点数的编码（解决正负号问题）<ul><li>原码、补码、反码、移码 (反码很少用)</li></ul></li></ul><h3 id="原码-补码等转换"><a href="#原码-补码等转换" class="headerlink" title="原码,补码等转换"></a>原码,补码等转换</h3><p>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014011205-1954288490.png" alt="img">该例中补码范围为7~ -8<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014027018-1172282605.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014029506-387719637.png" alt="img"></p><h3 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准:"></a>IEEE 754标准:</h3><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014035855-588428938.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014043723-1834347315.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014047780-592417996.png" alt="img"><br>特殊值表示方法:<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014107110-651415914.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014110678-1752685512.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014112684-2018827045.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014114738-920858372.png" alt="img"></p><h3 id="数据基本宽度"><a href="#数据基本宽度" class="headerlink" title="数据基本宽度:"></a>数据基本宽度:</h3><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014121001-1584897258.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014123031-2055759459.png" alt="img"></p><ol><li>数据储存顺序:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014133282-530607408.png" alt="img"><h1 id="数字逻辑电路"><a href="#数字逻辑电路" class="headerlink" title="数字逻辑电路"></a>数字逻辑电路</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014141589-877062665.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014143661-1720084070.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014147879-875583493.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014151433-548222357.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014154184-1918996099.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014159403-105480773.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014202581-2133901621.png" alt="img"><h2 id="数字逻辑基础"><a href="#数字逻辑基础" class="headerlink" title="数字逻辑基础"></a>数字逻辑基础</h2><h3 id="数字抽象"><a href="#数字抽象" class="headerlink" title="数字抽象:"></a>数字抽象:</h3><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014211440-1879372829.png" alt="img"><br>最大,最小项:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617154420879-246892569.png" alt="img"><h3 id="CMOS晶体管"><a href="#CMOS晶体管" class="headerlink" title="CMOS晶体管:"></a>CMOS晶体管:</h3><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014218473-1701541417.png" alt="img"><h3 id="CMOS逻辑门的实现"><a href="#CMOS逻辑门的实现" class="headerlink" title="CMOS逻辑门的实现:"></a>CMOS逻辑门的实现:</h3></li></ol><ul><li>非门:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014225342-1684552326.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014228805-372165172.png" alt="img"></li><li>与非门:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014311629-1656937126.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014315595-801550491.png" alt="img"></li><li>或非门:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014323596-1887228854.png" alt="img"></li><li>与门:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014345858-559510720.png" alt="img"></li><li>缓冲器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014353555-1707437596.png" alt="img"></li><li>k输入门:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014401103-720784620.png" alt="img"><h3 id="卡诺图化简"><a href="#卡诺图化简" class="headerlink" title="卡诺图化简"></a>卡诺图化简</h3>原理:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014410732-1177596238.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014413535-1829508656.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014420538-1770220417.png" alt="img"><h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要:"></a>概要:</h3><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615111421929-38883255.png" alt="img"><h3 id="原则"><a href="#原则" class="headerlink" title="原则:"></a>原则:</h3><ul><li>组合逻辑电路构成规则<ul><li>每个元件本身是组合逻辑电路</li><li>输出结点不能互连</li><li>输出结点不能反馈到输入端</li></ul></li></ul></li></ul><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615113316076-675689486.png" alt="img"></p><h3 id="组合逻辑电路设计"><a href="#组合逻辑电路设计" class="headerlink" title="组合逻辑电路设计:"></a>组合逻辑电路设计:</h3><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615113647300-280821413.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615113817859-72859607.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615113848789-1310083044.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615113927555-2059449505.png" alt="img"></p><h3 id="典型部件"><a href="#典型部件" class="headerlink" title="典型部件:"></a>典型部件:</h3><ul><li>译码器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615114623388-454552033.png" alt="img"><br>  实现:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615114643047-2001093471.png" alt="img"><br>  例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615114948386-1029309516.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615115008027-1902835266.png" alt="img"></li><li>编码器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615115026037-753238944.png" alt="img"><br>  实现:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615115259158-865173774.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615115421296-35896230.png" alt="img"></li><li>多路选择器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615115657254-1064106050.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615115730308-118332305.png" alt="img"></li><li>多路分配器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615115841142-274093000.png" alt="img"></li><li>半加器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615120105602-73430751.png" alt="img"></li><li>全加器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615120721566-86599296.png" alt="img"><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟:"></a>延迟:</h3><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615120911862-1625046908.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615120951994-2128772245.png" alt="img"><h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险:"></a>冒险:</h3>不同路径延迟作用在同一输出端而引起<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615121054648-1503790337.png" alt="img"></li></ul><h2 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615140803977-1142553144.png" alt="img"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>有限状态机:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615141014332-1804402180.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615141044170-1371196590.png" alt="img"><br>实现:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615162045287-1019254325.png" alt="img"></li><li>基本结构:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615162528277-1991129778.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615162729105-1295505024.png" alt="img"><h3 id="锁存器-触发器"><a href="#锁存器-触发器" class="headerlink" title="锁存器,触发器"></a>锁存器,触发器</h3></li><li>双稳态元件:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615163549733-1286660949.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615163655902-2036839185.png" alt="img"><br><strong>锁存器</strong>:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615163831192-465289383.png" alt="img"><strong>触发器</strong>:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615163903255-1116379847.png" alt="img"></li><li>SR锁存器:<ul><li>构造及状态转移:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615164034888-800583773.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615164137604-1444652696.png" alt="img"></li><li>功能:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615164212020-667306024.png" alt="img"></li></ul></li><li>D锁存器:<ul><li>构造:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615164448611-2027028338.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615164505432-867609112.png" alt="img"></li></ul></li><li>D触发器:<ul><li>构造:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615164630498-901957044.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615170258548-241737215.png" alt="img"></li><li>变种:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615170726230-1573410134.png" alt="img"></li></ul></li><li>T触发器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615170840361-284796448.png" alt="img"></li><li>总结:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615170906090-185067237.png" alt="img"><h3 id="关于写入的时序关系"><a href="#关于写入的时序关系" class="headerlink" title="关于写入的时序关系:"></a>关于写入的时序关系:</h3><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615170406815-1750143000.png" alt="img"><h3 id="同步时序逻辑电路设计"><a href="#同步时序逻辑电路设计" class="headerlink" title="同步时序逻辑电路设计"></a>同步时序逻辑电路设计</h3></li><li>概要:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615171000521-1042404083.png" alt="img"></li><li>实例:<ul><li>需求分析:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615171156803-659443706.png" alt="img"></li><li>状态图,状态表设计:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615171251343-1325001886.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615171351282-1446047309.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615171418884-440648236.png" alt="img"></li><li>状态化简:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615171520539-1827641358.png" alt="img"></li><li>状态编码:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615171558494-1566662640.png" alt="img"></li><li>电路设计:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615171945965-1704923181.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615172059360-1300953226.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615172142819-1127548503.png" alt="img"></li><li>电路分析:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615172306250-831357379.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615172343779-1164746009.png" alt="img"></li><li>定时分析:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615172403253-309066811.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615172841223-1786670929.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615172902822-1545949265.png" alt="img"><br>时间容限:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615172929943-1098079292.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615173030583-1616797346.png" alt="img"><h3 id="典型部件设计"><a href="#典型部件设计" class="headerlink" title="典型部件设计"></a>典型部件设计</h3></li></ul></li><li>计数器:<ul><li>异步<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616170447269-80816345.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616170604924-1790784680.png" alt="img"><ul><li>同步:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616171000121-1434773515.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616171136882-322969824.png" alt="img"></li></ul></li></ul></li><li>寄存器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616171619795-3078153.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616171651466-207488904.png" alt="img"></li><li>寄存器堆:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616171713416-446412266.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616171953653-904858171.png" alt="img"></li><li>移位寄存器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616172313405-1848305719.png" alt="img"><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616172403510-723571484.png" alt="img"></li></ol><h1 id="存储器阵列-了解"><a href="#存储器阵列-了解" class="headerlink" title="存储器阵列(了解)"></a>存储器阵列(了解)</h1><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616172757206-2070362942.png" alt="img"></p><h2 id="ROM-RAM"><a href="#ROM-RAM" class="headerlink" title="ROM,RAM"></a>ROM,RAM</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616172923931-85886264.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616172905821-615549170.png" alt="img"></p><ul><li>ROM:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616173522844-771321970.png" alt="img"></li><li>静态RAM<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616173540492-208114817.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616173601839-2006319454.png" alt="img"></li><li>动态RAM:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616173629685-208691975.png" alt="img"></li></ul><h1 id="运算部件设计"><a href="#运算部件设计" class="headerlink" title="运算部件设计"></a>运算部件设计</h1><h2 id="基本的运算部件"><a href="#基本的运算部件" class="headerlink" title="基本的运算部件"></a>基本的运算部件</h2><ol><li>概述<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616174913414-516038080.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616212554261-936378198.png" alt="img"></li><li>加法器:<ul><li>串行进位加法器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616175035504-633011718.png" alt="img"></li><li>并行进位加法器(CLA):<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616210601196-14641279.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616210922881-1332842223.png" alt="img"></li><li>n位带标志加法器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616211759296-1205979895.png" alt="img"></li><li>ALU:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616211958742-1264912173.png" alt="img"><h2 id="定点数运算-加减法-乘法"><a href="#定点数运算-加减法-乘法" class="headerlink" title="定点数运算(加减法,乘法)"></a>定点数运算(加减法,乘法)</h2></li></ul></li><li>概要:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616212614222-224700158.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616212633836-1942982383.png" alt="img"></li><li>加减法:<ul><li>引入:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616213842590-1422107177.png" alt="img"></li><li>实现:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616213936412-48182645.png" alt="img"></li><li>符号位使用:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616214238005-785234235.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616214325613-153839654.png" alt="img"></li><li>例子(溢出判断):<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616214724724-610308253.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616214908139-1921332475.png" alt="img"></li></ul></li><li>乘法:<ul><li>概要:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616215749040-1733200425.png" alt="img"></li><li>无符号数乘法:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616215042405-1845886866.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616215103991-1123599337.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616215323674-783602269.png" alt="img"><ul><li>实现:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616215427221-533641798.png" alt="img"></li></ul></li><li>原码乘法:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616215539153-548506723.png" alt="img"></li><li>补码(带符号数)乘法:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616220205547-2011425939.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616220254030-714929402.png" alt="img"></li></ul></li><li><p>小结:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616220539858-872790898.png" alt="img"></p></li><li><p>乘法溢出判断:<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014425627-1136493265.png" alt="img"></p><blockquote><p>eg:<br>在字长为32位的计算机上，某C函数原型声明为：</p><pre><code class="hljs">         `int imul_overflow(int x, int y);`</code></pre><p>该函数用于对两个int型变量x和y的乘积（也是int类型）判断是否溢出，若溢出则返回非0，否则返回0。请完成下列任务或回答下列问题。<br>（1）两个n位无符号数（带符号整数）相乘的溢出判断规则各是什么？</p><ul><li>无符号整数相乘： 若乘积的高n位为非0，则溢出。 </li><li>带符号整数相乘： 若乘积高n位的每一位都相同，且都等于乘积低n位的符号，则不溢出，否则溢出。<br>（2）已知入口参数x、y分别在寄存器a0、a1中，返回值在a0中，写出实现 <code>imul_overflow</code>函数功能的RISC-V汇编指令序列，并给出注解。<br>答案:<br>实现该功能的汇编指令序列不唯一。<br>某实现方案下的汇编指令序列如下： <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">&gt;<span class="hljs-keyword">mul </span> <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">a1</span>       <span class="hljs-comment"># x*y的低32位在t0中</span><br>&gt;<span class="hljs-keyword">mulh </span> <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">a1</span>       <span class="hljs-comment"># x*y的高32位在a0中</span><br>&gt;<span class="hljs-keyword">srai </span>  <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-number">31</span>       <span class="hljs-comment"># 乘积的低32位算术右移31位</span><br>&gt;<span class="hljs-keyword">xor </span> <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t0</span>       <span class="hljs-comment"># 按位异或，若结果为0，表示不溢出</span><br></code></pre></td></tr></table></figure>（3）使用64位整型（<code>long long</code>）变量来编写<code>imul_overflow</code>函数的C代码 或描述实现思想。<br>答案:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014432974-461643785.png" alt="img"><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616221543729-2133980917.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616221554185-1534318529.png" alt="img"></li></ul></blockquote></li></ol><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225515734-1243583867.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225613058-1778838519.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225628947-2114802024.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225642762-62666239.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225655443-1256057721.png" alt="img"></p><h2 id="指令设计"><a href="#指令设计" class="headerlink" title="指令设计"></a>指令设计</h2><ol><li>需求:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225203313-1369980965.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225303057-1665565339.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225738184-123729406.png" alt="img"></li><li>指令字地址码:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616225845939-2039625049.png" alt="img"></li><li>RISC-V数据类型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616230257641-719930468.png" alt="img"></li><li><p>寻址方式:<br>有效地址仅指存储器的地址<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616230610942-1737381163.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617160703443-750374208.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617160710236-139129348.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616230654402-1757044588.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616231304342-495155557.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616231353455-1655508064.png" alt="img"></p><blockquote><p>操作码编码例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616231928093-823704019.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616231942142-67939472.png" alt="img"><br>先确定有多少二地址指令(操作码位数最少),减去已知,余下条数x$2^6$(表示除二地址指令外余下操作码可生成多少一地址指令,因为不可与二地址操作码重复,只能取余下位数),减去已知,再x$2^6$,表示最多可生成多少零地址指令</p></blockquote></li><li><p>指令设计风格</p><ul><li>复杂的CISC:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616232613908-1436169275.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616232738051-2027211650.png" alt="img"></li><li>精简的RISC:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616232857013-1676107012.png" alt="img"></li></ul></li><li>异常和中断:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616233455087-629750308.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230616233511224-68261638.png" alt="img"></li><li>寄存器分配<br><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014440459-856412722.png" alt="img"><h2 id="RISC-V指令"><a href="#RISC-V指令" class="headerlink" title="RISC-V指令"></a>RISC-V指令</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014438713-807895000.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617160821957-1029354348.png" alt="img"></li></ol><ul><li>运算型:<ul><li>U型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617160911661-1051023052.png" alt="img"></li><li>I型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617181421400-1227415522.png" alt="img">(slt,sltu:set less than,即比较大小,小于置一)(移位指令:s; l(left):左移, r(right):右移; l(logical):即逻辑 ,a(algebraic):即算术)<blockquote><p>注意:<br>对数的装载:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617181956745-136571640.png" alt="img"></p></blockquote></li><li>R型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617182057738-936386676.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617182235506-1570647796.png" alt="img"><blockquote><p>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617182323257-256385082.png" alt="img"></p></blockquote></li></ul></li><li>控制转移类指令(J,I-jarl,B型):<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617182503098-1077805181.png" alt="img"> <img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617182731036-2032781615.png" alt="img"></li><li>存储器访问类指令(I,S型):<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617182833156-1615790528.png" alt="img"></li><li>其他指令:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617183213938-817010820.png" alt="img"></li></ul><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617191902334-1645223868.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617191935091-1120606849.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617192119207-1408783348.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617193518774-40868360.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617193830223-1206056129.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617193901159-1118012343.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617193918320-1141317272.png" alt="img"></p><ol><li>吞吐率 = 单位时间内运行的作业（指令）数（有或无负载/干扰）</li><li>CPU执行时间:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014445262-584809356.png" alt="img"><br>CPI计算公式:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230615014449524-1155762076.png" alt="img"><h2 id="CPU设计"><a href="#CPU设计" class="headerlink" title="CPU设计"></a>CPU设计</h2></li><li>拓展器:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617191136692-1315284542.png" alt="img"><h2 id="流水线设计"><a href="#流水线设计" class="headerlink" title="流水线设计"></a>流水线设计</h2></li><li>分析引入:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617231759612-1489066188.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230617231926780-693031233.png" alt="img"></li><li>各类指令执行过程:</li></ol><ul><li>R型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618000227865-413991681.png" alt="img"></li><li>Store指令:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618000451392-1318644206.png" alt="img"></li><li>I型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618000557271-421450095.png" alt="img"></li><li>U型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618000630206-411549797.png" alt="img"></li><li>B型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618000718014-1357304928.png" alt="img"></li><li>J型:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618000933696-1674933047.png" alt="img"></li></ul><ol><li>数据通路:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618003723821-31434128.png" alt="img"><blockquote><p>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618005109813-1913474353.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618010526168-1909773333.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618010609220-1213931492.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618011309032-265369294.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618012333296-1682513365.png" alt="img"></p></blockquote></li><li>控制信号:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618012515521-923018032.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618012549415-1044961050.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618012627266-1422848107.png" alt="img"></li><li>小结:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618012751765-2010241083.png" alt="img"><h2 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h2><h3 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h3><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618014229606-958339050.png" alt="img"><h3 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h3><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618014301416-876530245.png" alt="img"><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3>引入:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618014352683-185370681.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618014410798-593910770.png" alt="img"><br>解决方法:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618014440139-218600862.png" alt="img"></li></ol><ul><li>方案一:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020454958-2012001345.png" alt="img"></li><li>方案二:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020514210-751911111.png" alt="img"></li><li>方案三:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020532578-1358942220.png" alt="img"></li><li>方案四:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020603800-506609591.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020642993-951557124.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020701837-1122682609.png" alt="img"><blockquote><p>特例:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020729422-380750161.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020746464-1738754659.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020837454-450652220.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020941935-1966452937.png" alt="img"></p></blockquote></li><li>方案五:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618020953662-512889719.png" alt="img"><h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618023016088-509472141.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618024021854-119450744.png" alt="img"><br>解决方法:</li><li>方案一:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618024249085-64419415.png" alt="img"></li><li>方案二:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230618024313274-1493004563.png" alt="img"></li><li>方案三:<ul><li>静态分支预测:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619170604259-802213053.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619210943733-1514384522.png" alt="img"></li><li>动态分支预测:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619211213264-1925743428.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619211717714-1420056995.png" alt="img"><ul><li>一位预测位:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619211929789-1245567111.png" alt="img"></li><li>二位预测位:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619212046575-1572849652.png" alt="img"></li></ul></li></ul></li><li>方案四:<img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619212106761-509651391.png" alt="img"><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619212142442-1841851462.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619212153328-995677144.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202306/3125312-20230619212201691-1933683762.png" alt="img"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数电与计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分期中总结</title>
    <link href="/2023/04/14/%E5%BE%AE%E7%A7%AF%E5%88%86%E6%9C%9F%E6%9C%AB/"/>
    <url>/2023/04/14/%E5%BE%AE%E7%A7%AF%E5%88%86%E6%9C%9F%E6%9C%AB/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#微分学">微分学</a></li><li><a href="#多元积分">多元积分</a></li><li><a href="#级数正项级数任意项级数幂级数">级数(正项级数,任意项级数,幂级数)</a><ul><li><a href="#正项级数收敛判别方法">正项级数收敛判别方法</a></li></ul></li></ul><h1 id="微分学"><a href="#微分学" class="headerlink" title="微分学"></a>微分学</h1><ol><li>拉格朗日中值：在(a,b)的区间内，定义了$f(x)$，则有$f(x_1)-f(x_2)=f’(\xi)(x_1-x_2),\xi\in(x_1,x_2)$</li><li>若$f’’<em>{xy}(x,y)与f’’</em>{yx}(x,y)在(x,y)处皆连续，则f’’<em>{xy}(x,y)=f’’</em>{yx}(x,y)在(x,y)，与求导次序无关$</li><li>全微分(用来代替全增量)：有函数$z=f(x,y)$，点P(x,y)，若$\Delta z=f(x+\Delta x,y+\Delta y)$可表示为$\Delta z=A\Delta x+B\Delta y+o(\rho)$，其中$A=\frac{\partial z}{\partial x},B=\frac{\partial z}{\partial y},\rho=\sqrt{(\Delta x)^2+(\Delta y)^2}$,则$f(x,y)$在$(x,y)$处可微$\;$,其中全微分为其线性部分$dz=A\Delta x+B\Delta y$</li><li>可微则$z=f(x,y)$可偏导,且偏导在(x,y)处连续,同时称为连续可微<br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415111350391-1777238050.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415111358851-1283366244.png" alt="img"></li><li>隐函数的偏导数:<ul><li>对$P_0(x_0,y_0)$,设$F(P_0)=0$,则存在唯一的$y=f(x)$,使得$F(x,f(x))=0$,$f$连续可微,$f(x_0)=y_0$且$f’(x)=-\frac{F’_x(x,y)}{F’_y(x,y)}$</li><li>同上,对$P_0(x_0,y_0,z_0)$,设$F(P_0)=0$,则存在唯一的$z=f(x,y)$,使得$F(x,y,f(x,y))=0$,$f$连续可微,$f(x_0,y_0)=z_0$且$\frac{\partial f}{\partial x}=-\frac{F’_x(x,y,z)}{F’_z(x,y,z)}$,$\frac{\partial f}{\partial y}=-\frac{F’_y(x,y,z)}{F’_z(x,y,z)}$</li><li>隐函数存在定理3<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415115102684-1663057538.png" alt="img"></li></ul></li><li>空间曲线的切线和法平面<ul><li>要点:&emsp;对曲面$F(x,y,z)=0$, 设$x,y,z$可化为参数方程$x=x(t),y=y(t),z=z(t)$, 则在$P_0(x_0,y_0,z_0)$处,曲面的法向量 ==$\overrightarrow n=(F’_x,F’_y,F’_z)$==, 切向量为$(x’(t),y’(t),z’(t))$ ,由此可推出曲线在该点的 点法式的切平面,法线</li><li>若曲线由两个方程的方程组决定$\begin{cases}F(x,y,z)=0 \ G(x,y,z)=0\end{cases}$,则取法向量$n_1=(F’_x,F’_x,F’_z),n_2=(G’_x,G’_y,G’_z)$,切向量为$n_1*n_2$</li></ul></li><li>空间曲面的切平面和法线<ul><li>若空间曲面由$F(x,y,z)=0$表示,则同上, 法向量为$\overrightarrow n=(F’_x,F’_y,F’_z)$, 由此求出切平面</li><li>若空间曲面由参数方程$x=x(u,v),y=y(u,v),z=z(u,v)$表示,对$u,v$求偏导,则法向量为$\overrightarrow n=(x’_u,y’_u,z’_u)\times(x’_v,y’_v,z’_v)$, 由此求出切平面</li></ul></li><li>极值和条件极值:<ul><li>二元函数的泰勒公式:若$f(x,y)$在$(x<em>0,y_0)$处可微,则$f(x,y)$在$(x_0,y_0)$处的泰勒公式为$f(x,y)=f(x_0,y_0)+f’_x(x_0,y_0)(x-x_0)+f’_y(x_0,y_0)(y-y_0)+\frac{1}{2}f’’</em>{xx}(\xi,\eta)(x-x<em>0)^2+\frac{1}{2}f’’</em>{yy}(\xi,\eta)(y-y<em>0)^2+\frac{1}{2}f’’</em>{xy}(\xi,\eta)(x-x_0)(y-y_0),\xi \in(x_0,x), \eta \in(y_0,y)$</li><li>极值判别法1: 记$\mu(x,y)=f’_x(x,y)(x-x_0)+f’_y(x,y)(y-y_0)$,则$\mu(x,y)&gt;0$时,点$(x_0,y_0)$为极小值点;$\mu(x,y)&lt;0$时,点$(x_0,y_0)$为极大值点;</li><li>极值判别法2: 当$f’<em>x(x_0,y_0)=f’_y(x_0,y_0)=0$时,令$A=f’’</em>{xx}(x<em>0,y_0),B=f’’</em>{xy}(x<em>0,y_0),C=f’’</em>{yy}(x<em>0,y_0)$;<br>&emsp;&emsp;由于$f(x,y)-f(x_0,y_0)=f’_x(x_0,y_0)\Delta x+f’_y(x_0,y_0)\Delta y+\frac{1}{2}(f’’</em>{xx}(\xi,\eta)(\Delta x)^2+2f’’<em>{xy}(\xi,\eta)(\Delta x\Delta y)+f’’</em>{yy}(x<em>0,y_0)(\Delta y)^2)$,<br>&emsp;&emsp;化为一元二次方程形式: $f(x,y)-f(x_0,y_0)\sim f’’</em>{xx}(\xi,\eta)(\frac{\Delta x}{\Delta y})^2+2f’’<em>{xy}(\xi,\eta)(\frac{\Delta x}{\Delta y})+f’’</em>{yy}(x_0,y_0)$: <ul><li>则$B^2-AC<0,A>0$时,点$(x_0,y_0)$为极小值点——方程无解且总值大于0$\rightarrow f(x,y)&lt;f(x_0,y_0)$总成立 ;</0,A></li><li>$B^2-AC<0,A<0$时,点$(x_0,y_0)$为极大值点----方程无解且总值小于0$\rightarrow f(x,y)>f(x_0,y_0)$总成立;</0,A<0$时,点$(x_0,y_0)$为极大值点----方程无解且总值小于0$\rightarrow></li><li>$B^2-AC&gt;0$时,点$(x_0,y_0)$不为极值点——方程有解$\rightarrow f(x,y)$大于或小于$f(x_0,y_0)$;</li></ul></li><li>条件极值: 设函数$f(x,y,z)$连续可微,函数$\varphi(x,y,z)$连续可微,且$f(x,y,z)$满足约束方程$\varphi(x,y,z)=0$的条件极值在点$P<em>0(x_0,y_0,z_0)$取得,令$F(x,y,z,\lambda)=f(x,y,z)=\lambda \varphi(x,y,z)$,则$P_0(x_0,y_0,z_0)$可由以下方程组求出:<br>$\begin{cases}F’_x=f’_x+\lambda\varphi’_x=0\ F’_x=f’_y+\lambda\varphi’_y=0 \ F’_z=f’_z+\lambda\varphi’_z=0 \ F’</em>\lambda=\varphi(x,y,z)=0\end{cases}$</li></ul></li><li>最大值,最小值:<br> 求驻点,计算出最大,最小值;或根据问题,只有一个驻点,且最大,最小值一定在区域内,判断边界点后,该驻点为最大, 最小值点.</li><li>方向导数:  <ul><li>对向量的方向余弦$\overrightarrow l=(cos(\alpha),cos(\beta),cos(\gamma))$和函数$f(x,y,z)$,  $f(x,y,z)$的方向导数为$\frac{\partial f}{\partial \overrightarrow l}(x,y,z)=\frac{\partial f}{\partial x}<em>cos(\alpha)+\frac{\partial f}{\partial y}</em>cos(\beta)+\frac{\partial f}{\partial z}*cos(\gamma)$,并记$\bigtriangledown f(P_0)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z})$</li><li>求函数沿某方向变化最快,即$|\frac{\partial f}{\partial \overrightarrow l}(x,y,z)|$最大时,  因为$|\frac{\partial f}{\partial \overrightarrow l}(x,y,z)|=|\bigtriangledown f(P_0)||\overrightarrow n|cos\theta$,则此时$\theta=0/\pi$,$\overrightarrow n//\overrightarrow {\bigtriangledown f(P_0)}$,即$\overrightarrow n=\frac{\bigtriangledown f(P_0)}{|\bigtriangledown f(P_0)|}$时增长最快,$\overrightarrow n=-\frac{\bigtriangledown f(P_0)}{|\bigtriangledown f(P_0)|}$减少最快<h1 id="多元积分"><a href="#多元积分" class="headerlink" title="多元积分"></a>多元积分</h1><h1 id="级数-正项级数-任意项级数-幂级数"><a href="#级数-正项级数-任意项级数-幂级数" class="headerlink" title="级数(正项级数,任意项级数,幂级数)"></a>级数(正项级数,任意项级数,幂级数)</h1><h2 id="正项级数收敛判别方法"><a href="#正项级数收敛判别方法" class="headerlink" title="正项级数收敛判别方法"></a>正项级数收敛判别方法</h2></li></ul></li><li>$\lim<em>{n-&gt;\infty}(a</em>{n+1} /a_n)$</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>微积分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学期末总结</title>
    <link href="/2023/04/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#命题逻辑">命题逻辑</a><ul><li><a href="#命题表达式">命题表达式</a></li><li><a href="#将自然语言翻译成命题表达式">将自然语言翻译成命题表达式</a></li><li><a href="#命题表达式的真值表以及永真式矛盾式与可能式">命题表达式的真值表以及永真式、矛盾式与可能式</a></li><li><a href="#逻辑等价">逻辑等价</a></li><li><a href="#常用的逻辑等价">常用的逻辑等价</a></li><li><a href="#命题逻辑公式的范式">命题逻辑公式的范式</a></li><li><a href="#命题逻辑的自然演绎规则">命题逻辑的“自然演绎”规则</a></li></ul></li><li><a href="#谓词逻辑及自然语言的翻译">谓词逻辑及自然语言的翻译</a></li><li><a href="#证明方法">证明方法</a></li><li><a href="#集合及其运算">集合及其运算</a></li><li><a href="#关系及其运算">关系及其运算</a></li><li><a href="#函数及其运算">函数及其运算</a></li><li><a href="#关系闭包和等价">关系闭包和等价</a></li><li><a href="#偏序和偏序格">偏序和偏序格</a></li><li><a href="#集合的基数">集合的基数</a></li><li><a href="#数论初步">数论初步</a></li><li><a href="#归纳与递归">归纳与递归</a></li><li><a href="#计数">计数</a></li><li><a href="#离散概率">离散概率</a></li><li><a href="#代数系统和群">代数系统和群</a></li></ul><h1 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h1><h2 id="命题表达式"><a href="#命题表达式" class="headerlink" title="命题表达式"></a>命题表达式</h2><p>$p\bigvee q,p\bigwedge q,$<br>$p\rightarrow q=\neg{p}\bigvee q=\neg{q}\rightarrow\neg{p}$,<br>其真值表如下：<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230414234921637-1080611651.png" alt="img"><br>$p\leftrightarrow q=(p\rightarrow q)\bigwedge(q\rightarrow p)$<br>其真值表如下：<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415001003795-592965966.png" alt="img"><br>运算符优先级：$\neg&gt;\bigwedge&gt;\bigvee&gt;\rightarrow&gt;\leftrightarrow$</p><h2 id="将自然语言翻译成命题表达式"><a href="#将自然语言翻译成命题表达式" class="headerlink" title="将自然语言翻译成命题表达式"></a>将自然语言翻译成命题表达式</h2><p>一个例子：<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415001117304-300645479.png" alt="img"></p><h2 id="命题表达式的真值表以及永真式、矛盾式与可能式"><a href="#命题表达式的真值表以及永真式、矛盾式与可能式" class="headerlink" title="命题表达式的真值表以及永真式、矛盾式与可能式"></a>命题表达式的真值表以及永真式、矛盾式与可能式</h2><p>  &emsp;</p><h2 id="逻辑等价"><a href="#逻辑等价" class="headerlink" title="逻辑等价"></a>逻辑等价</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415001729745-1806161999.png" alt="img"></p><h2 id="常用的逻辑等价"><a href="#常用的逻辑等价" class="headerlink" title="常用的逻辑等价"></a>常用的逻辑等价</h2><p><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415001835667-657307310.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415002002556-960422294.png" alt="img"></p><h2 id="命题逻辑公式的范式"><a href="#命题逻辑公式的范式" class="headerlink" title="命题逻辑公式的范式"></a>命题逻辑公式的范式</h2><ul><li>包含所有命题变元或其否定一次仅一次的简单合取式($\land$)，称为极小项；</li><li>包含所有命题变元或其否定一次仅一次的简单析取式($\lor$)，称为极大项；</li><li>由有限个极小项组成的析取范式称为主析取范式(和式$\lor$)； </li><li>由有限个极大项组成的合取范式称为主合取范式(积式$\land$)。<h2 id="命题逻辑的“自然演绎”规则"><a href="#命题逻辑的“自然演绎”规则" class="headerlink" title="命题逻辑的“自然演绎”规则"></a>命题逻辑的“自然演绎”规则</h2><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230415234911544-1339122674.png" alt="img"><h1 id="谓词逻辑及自然语言的翻译"><a href="#谓词逻辑及自然语言的翻译" class="headerlink" title="谓词逻辑及自然语言的翻译"></a>谓词逻辑及自然语言的翻译</h1><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416010555014-409462336.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416011003550-1652528878.png" alt="img"><br>注意:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416011149607-965455070.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416011445893-1485446859.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416011508811-697382738.png" alt="img"><br>例子:<br>1.<br><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416011533931-1032413969.png" alt="img"><br>2.<br><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416011641473-1860006410.png" alt="img"><br>注意:全称量词一般用蕴含$\rightarrow$,存在量词一般用合取$\land$(因为若条件为假,则语句为真,此时可能对)<h1 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h1><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416102326832-1516375779.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416102342500-813764848.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416102438280-397179033.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416102754908-2054669560.png" alt="img"><h1 id="集合及其运算"><a href="#集合及其运算" class="headerlink" title="集合及其运算"></a>集合及其运算</h1><ol><li>幂集:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105002013-1734052406.png" alt="img">,  若$|A|=n$,则$|P(A)|=2^n$</li><li>集合的运算:交,并,补<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105133442-2007149811.png" alt="img">,<br>对称差:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105202441-1506010215.png" alt="img"><br>性质:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105426126-1647572814.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105454763-1254623861.png" alt="img"></li><li>自然数的定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105727907-393209761.png" alt="img"></li><li>特殊例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105750799-701287542.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416110219916-1461500857.png" alt="img"></li><li>笛卡尔积:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105837181-458156926.png" alt="img"></li><li>集合等式的证明:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416105930699-1082352792.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416110055821-1136085463.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416110119940-987077219.png" alt="img"><h1 id="关系及其运算"><a href="#关系及其运算" class="headerlink" title="关系及其运算"></a>关系及其运算</h1></li><li>特殊的关系:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416110738643-24549801.png" alt="img"></li><li>关系的运算:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416110916133-621856307.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111059583-155636464.png" alt="img"><br>重点: 关系的复合:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111150540-1369188229.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111210637-960567357.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111222376-1018415828.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111318368-1202425992.png" alt="img"></li><li>0-1矩阵运算(成员表):<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111358639-399259368.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111828440-1676795162.png" alt="img"></li><li>关系的性质:</li></ol></li><li>自反性:注意自反(对$\forall a\in A$),反自反,非自反的关系<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111912977-55194360.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416111939394-1402906185.png" alt="img"></li><li>:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416112254132-2129446923.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416112358770-710730787.png" alt="img"> :前提不满足,则后续不用证明,结论为真<br><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416112448120-1099993885.png" alt="img"> <img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416112652719-1409958179.png" alt="img"></li><li>传递性:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416112711850-986637380.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416112730494-826818473.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416113028040-1714076869.png" alt="img"><ol><li>关系的运算与性质的保持:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416113159812-66280532.png" alt="img"><h1 id="函数及其运算"><a href="#函数及其运算" class="headerlink" title="函数及其运算"></a>函数及其运算</h1></li><li>定义:定义域,伴域,值域,像,原像<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416113353635-719112230.png" alt="img"></li><li>定义:$B^A$<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416132035716-1352269396.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416132044797-1458519133.png" alt="img"></li><li>并集,交集的关系:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416132129166-1806552344.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416132139090-1102157538.png" alt="img"></li><li>函数性质:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416132251918-1546402162.png" alt="img"></li><li>反函数,函数的复合:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416132732553-1881898710.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416132746116-1556362099.png" alt="img"><br>满射证明:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416133258827-995476594.png" alt="img"><br>单射证明:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416133437059-1850161762.png" alt="img"><h1 id="关系闭包和等价"><a href="#关系闭包和等价" class="headerlink" title="关系闭包和等价"></a>关系闭包和等价</h1></li><li>定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416203902802-1566775256.png" alt="img"><br>包含关系R,满足性质P的最小关系</li><li>自反闭包:</li></ol></li><li>定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416204106119-1289681795.png" alt="img"></li><li>计算公式:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416204700307-583260775.png" alt="img"><ol><li>对称闭包:</li></ol></li><li>计算公式:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416204757037-2000980971.png" alt="img"><ol><li>传递闭包:</li></ol></li><li>连通关系:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416204852421-1731407314.png" alt="img"><br>$R^*$即为对存在通路的元素$a,b$ ($a\rightarrow t_1,t_1\rightarrow t_2,···,\rightarrow b$) ,搭桥:$a\rightarrow b$,因此满足传递性</li><li>计算公式:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416205042544-1711092172.png" alt="img"></li><li>有限集合上的传递闭包:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416205625253-1236281775.png" alt="img"><ol><li>定义证明闭包性质:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416210554628-211201734.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416210604096-1817469851.png" alt="img"></li><li>Warshall算法求传递闭包:</li></ol></li><li>公式:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416210720640-1687771183.png" alt="img"></li><li>过程:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416210733415-810764711.png" alt="img"><ol><li>按对角线圈出第i行i列,</li><li>由该列中的1计算出除i行i列中的1</li><li>等价关系:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416211011260-350003378.png" alt="img"></li><li>等价类:</li></ol></li><li>定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416211033164-351863241.png" alt="img"></li><li>代表元素:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416211059527-1790454544.png" alt="img"><ol><li>商集:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416211645499-360120774.png" alt="img"><br>对A的划分:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416211858429-1057203962.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416212046533-967373461.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416212054532-979693060.png" alt="img"><h1 id="偏序和偏序格"><a href="#偏序和偏序格" class="headerlink" title="偏序和偏序格"></a>偏序和偏序格</h1></li><li>偏序关系定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416212841059-450000271.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213517241-995535747.png" alt="img"></li><li>可比,全序,覆盖定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416212903055-850859089.png" alt="img"></li><li>偏序集和哈斯图:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213012272-141018741.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213028331-147233185.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213134116-489567016.png" alt="img"></li><li>偏序集中特殊元素及性质:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213222762-1560566864.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213230942-1446058286.png" alt="img">上,下界需为共同交点元素<br>图示:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213410780-1771596073.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213421924-1199061877.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213447128-1242143641.png" alt="img"></li><li>格:</li></ol></li><li>定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213544841-503410098.png" alt="img">任意两个元素均有上下确界,并重新定义了$\land,\lor$</li><li>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416213728047-959215298.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416214001713-594220586.png" alt="img"></li><li>对偶定理<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416214302365-758008977.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416214318779-939966879.png" alt="img"></li></ul><h1 id="集合的基数"><a href="#集合的基数" class="headerlink" title="集合的基数"></a>集合的基数</h1><ol><li>等势关系定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416133806596-288990973.png" alt="img"></li><li><p>可列集:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416133922878-1923146320.png" alt="img"><br>特别的:可列个可列集的并集,笛卡尔积仍然是可列集合</p></li><li><p>可数集:有限的或与自然数集等势的集合</p></li><li>有限与无限集:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416133949809-600792813.png" alt="img"><ul><li>一个例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416134525547-1911985556.png" alt="img"></li><li>康托尔定理:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416134601993-54613942.png" alt="img"></li></ul></li><li>集合的优势关系:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416134644214-1718971161.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416163201003-1861193196.png" alt="img"><br>性质:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416154754527-1264493130.png" alt="img"><br>一个例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416154825154-152467310.png" alt="img"><br>等势关系R=对应的双射f,元素为集合<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416155149900-230642515.png" alt="img"></li><li>集合的基数:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416160336581-660324172.png" alt="img"><br>一个例子:康托对角线法—-<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416160529455-538363711.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416160545871-447626196.png" alt="img"><br>另一个例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416160833854-1649624966.png" alt="img"> 其中${0,1}^N$表示N中元素是否存在的所有可能的集合,即可代表N的幂集<h1 id="数论初步"><a href="#数论初步" class="headerlink" title="数论初步"></a>数论初步</h1></li><li>模的基本性质:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416161537195-1381022096.png" alt="img"></li><li>最大公约数:<ul><li>定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416161614888-980870710.png" alt="img"></li><li>性质:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416161628643-1004454284.png" alt="img"></li><li>第一条性质(贝祖定理)的证明:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416161822908-159049669.png" alt="img"></li></ul></li><li>算术基本定理:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416162122102-1085734187.png" alt="img"></li><li>欧拉函数与欧拉定理:<ul><li>欧拉函数:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416163318566-891016423.png" alt="img"></li><li>欧拉定理与费马小定理:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416163822339-863912187.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416163835737-1945605109.png" alt="img"><h1 id="归纳与递归"><a href="#归纳与递归" class="headerlink" title="归纳与递归"></a>归纳与递归</h1></li></ul></li><li>数学归纳法:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416164451050-120862519.png" alt="img"><br>良序公理:正整数集合的非空子集都有一个最小元素</li><li>强数学归纳法:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416164851662-262776126.png" alt="img"><br>良序公理证明:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416165343432-455585017.png" alt="img"></li><li>递归定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416165953776-361573715.png" alt="img"></li><li>结构归纳法:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416170054635-1268345087.png" alt="img"><h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1></li><li>容斥原理:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416170940604-184643232.png" alt="img"></li><li>错位排序:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416171636524-1985320353.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416171650872-1022934205.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416171657089-325629978.png" alt="img"></li><li>鸽笼原理:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416171720595-36044763.png" alt="img"><br>一般的:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416171913294-98000764.png" alt="img"><br>特殊例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416172026345-361093376.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416172033985-1688924479.png" alt="img"></li><li>排列组合:隔板法,特殊值法,全排和选择</li><li>二项式定理:赋值法,展开法,<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416172436004-655838128.png" alt="img"><h1 id="离散概率"><a href="#离散概率" class="headerlink" title="离散概率"></a>离散概率</h1></li><li>基于集合论的定义:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416172624920-1111638813.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416172646927-1650099144.png" alt="img"></li><li>条件概率:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416190859706-2077041237.png" alt="img"></li><li>贝叶斯定理:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416190929351-1361979448.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416191745466-631037979.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416191753389-989557239.png" alt="img"><img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416191803206-163103538.png" alt="img"></li><li>事件独立性:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416193442653-796844950.png" alt="img"></li><li>随机变量:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416193600170-1400110500.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416193639891-2112738208.png" alt="img"></li><li>期望:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416193731435-1869698404.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416193752491-129445907.png" alt="img"><br>条件期望:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416194854895-795437598.png" alt="img"><br>期望的线性性:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416194950869-276678726.png" alt="img"><br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416200603157-989065328.png" alt="img"><br>独立随机变量的期望:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416200531856-1679414004.png" alt="img"></li><li>方差:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416200258506-1664116060.png" alt="img"><br>另一个计算公式:$V(X)=E(X^2)-E(X)^2$<br>例子:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416200357713-2086168139.png" alt="img"><br>性质:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416200419576-2119912445.png" alt="img"><br>PS:各种期望计算公式:<img src="https://img2023.cnblogs.com/blog/3125312/202304/3125312-20230416200800523-54757665.png" alt="img"><br>二项分布:X~B(n,p),X可能发生,可能不发生,发生的概率为p,则$E(X)=np,D(X)=np(1-p)$;<br>几何分布:在$n$次实验中,前$k-1$次均失败,第$k$次成功的概率,其中每次成功的概率为$p$,则该概率为$p<em>k=(1-p)^{k-1}p$,期望为$E(x)=\frac{1}{p}$,方差为$D(x)=\frac{1-p}{p^2}$;<br>超几何分布:考虑$N=N_1+N_2$个外表相同的物品，其中有$N_1$个同类物品与另一类的$N_2$个物品(次品)；抽取$n$个物品，每个物品的抽取等概率随机。<br>则抽取到x个$N_1$物品的概率为:$P(X)=\frac{C^{\,x}</em>{N<em>1}*C^{\,n-1}</em>{N_1}}{C^{\,n}_N}$,期望为$E(X)=n\frac{N_1}{N}$,方差为:$D(X)=n<em>\frac{N_1}{N}</em>\frac{N_2}{N}*\frac{N-n}{N-1}$;</li></ol><h1 id="代数系统和群"><a href="#代数系统和群" class="headerlink" title="代数系统和群"></a>代数系统和群</h1>]]></content>
    
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法与数据结构</title>
    <link href="/2023/01/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/01/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1>二分查找：</h1><h2 id="模板①：">模板①：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>  <span class="hljs-type">int</span> middle = left + (right - left) / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (满足XXX) &#123;<br>    right = middle;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    left = middle + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125; <br><span class="hljs-comment">//注意是先改变右值</span><br></code></pre></td></tr></table></figure><h2 id="模板②：">模板②：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>  <span class="hljs-comment">// +1是为了让相除结果向上取整，这个地方就是两套模板的区别之一</span><br>  <span class="hljs-type">int</span> middle = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (满足XXX) &#123;<br>    left = middle;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    right = middle - <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;  <br><span class="hljs-comment">//注意是先改变左值</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2023/01/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/01/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1>例一：最长不下降子序列</h1><h2 id="方法一：时间复杂度O-nlogn">方法一：<a href="https://www.cnblogs.com/itlqs/p/5743114.html">时间复杂度O(nlogn)</a></h2><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//最长不下降子序列nlogn  Song </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">40005</span>];<br><span class="hljs-type">int</span> d[<span class="hljs-number">40005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)  <span class="hljs-comment">//0个元素特判一下 </span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    d[<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>];  <span class="hljs-comment">//初始化 </span><br>    <span class="hljs-type">int</span> len=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i]&gt;=d[len]) d[++len]=a[i];  <span class="hljs-comment">//如果可以接在len后面就接上，如果是最长上升子序列，这里变成&gt; </span><br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">//否则就找一个最该替换的替换掉 </span><br>        &#123;<br>            <span class="hljs-type">int</span> j=<span class="hljs-built_in">upper_bound</span>(d+<span class="hljs-number">1</span>,d+len+<span class="hljs-number">1</span>,a[i])-d;  <span class="hljs-comment">//找到第一个大于它的d的下标，如果是最长上升子序列，这里变成lower_bound </span><br>            d[j]=a[i]; <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,len);    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>例子：1,7,6,2,3,4<br>结果：4<br>解释：最长不下降子序列为1,2,3,4</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/17/hello-world/"/>
    <url>/2023/01/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>New Article</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
